<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shader Example</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="webgl-canvas"></canvas>

<script>
    const canvas = document.getElementById("webgl-canvas");
    const gl = canvas.getContext("webgl");

    if (!gl) {
        alert("WebGL not supported!");
    }

    const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_uv = (a_position + 1.0) / 2.0;
        }
    `;

    const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_uv;
        uniform float iTime;
        uniform vec2 iResolution;

        void main() {
            // Ensure resolution and fragCoord are being passed correctly
            vec2 uv = v_uv;
            uv.y *= 1.25; // Scale the y coordinate for better aspect ratio

            // Use a simple sine wave pattern for color debugging
            float colorValue = 0.5 + 0.5 * sin(iTime + uv.x * 10.0); // Simple time-based color change

            // Set the color based on the sine function
            gl_FragColor = vec4(colorValue, colorValue, colorValue, 1.0);
        }
    `;

    function compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("Shader compile failed with: " + gl.getShaderInfoLog(shader));
        }

        return shader;
    }

    function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Program failed to link: " + gl.getProgramInfoLog(program));
        }

        return program;
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height); // Set the viewport to the full size of the canvas
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);

    gl.useProgram(program);

    const positionLocation = gl.getAttribLocation(program, "a_position");
    const timeLocation = gl.getUniformLocation(program, "iTime");
    const resolutionLocation = gl.getUniformLocation(program, "iResolution");

    const vertices = new Float32Array([
        -1.0, -1.0,
         1.0, -1.0,
        -1.0,  1.0,
         1.0,  1.0
    ]);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLocation);

    function render(time) {
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform1f(timeLocation, time * 0.001);  // Pass time to shader
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height); // Pass the resolution to the shader
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); // Draw the rectangle covering the canvas
        requestAnimationFrame(render);
    }

    requestAnimationFrame(render);
</script>
</body>
</html>
